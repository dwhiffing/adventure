// Generated by CoffeeScript 1.7.1
(function() {
  var canvasSize, checkAdjacent, checkArrowColour, checkCollisions, checkForFalling, checkMatches, checkPath, create, createGame, debugTiles, deselectBefore, doMatch, doNextAction, drawArrow, height, increaseCombo, increaseScore, initBG, initGrid, initLine, initTile, initUI, initVars, lineToTile, match, newRoom, popTile, preload, render, resetArrow, resetCombo, resetPath, setPlayerCoords, setRoomSize, setSize, spawnPlayer, spawnTile, startPath, update, walkPath, width, _;

  doNextAction = function() {
    if (_.tilesToPop && _.tilesToPop.length > 0) {
      popTile();
      return _.time.events.add(_.popTime, doNextAction);
    } else {
      checkMatches();
      if (_.tileArray.getMatches()) {
        _.gridMoving = false;
        return _.time.events.add(_.popTime, doNextAction);
      } else {
        return _.time.events.add(500, function() {
          _.tiles.callAll("destroy");
          _.sound.play("new");
          fadeOut();
          return _.time.events.add(2000, newRoom);
        });
      }
    }
  };

  popTile = function() {
    var tile;
    _.gridMoving = true;
    tile = _.tilesToPop.shift();
    if (tile === _.hero.t) {
      _.lTile = tile.o;
      tile = _.tilesToPop.shift();
    }
    if ((tile != null) && tile.o.inMatch || tile.o.type === -1) {
      if (tile.o.type !== -1) {
        tile.o.destroy();
        _.time.events.add(_.popTime / 2, function() {
          return _.sound.play("pop" + _.combo);
        });
      }
      moveHero(tile.o.x, tile.o.y);
      _.hero.t = tile;
      _.lTile = tile.o;
      _.time.events.add(_.popTime, setPlayerCoords);
      _.hero.t.x = tile.o.t.x;
      return _.hero.t.y = tile.o.t.y;
    }
  };

  setPlayerCoords = function() {
    var tile;
    _.hero.t.type = -1;
    tile = _.tileArray.getPiece({
      x: _.hero.t.x,
      y: _.hero.t.y
    });
    tile.o.reset();
    _.tiles.callAll("updateType");
    return tile.o.type = 0;
  };

  checkCollisions = function(tile) {
    if (_.uiFade.alpha === 0.4) {
      if (!tile.selected) {
        return checkAdjacent(tile);
      } else {
        return deselectBefore(tile);
      }
    }
  };

  checkAdjacent = function(nTile) {
    var dir, nb, neighbours, _results, _results1;
    if (_.lTile != null) {
      neighbours = _.lTile.t.neighbours();
      _results = [];
      for (dir in neighbours) {
        if (nTile.t !== _.hero.t) {
          if (nTile.t === neighbours[dir]) {
            if (match(nTile, _.lTile) || (_.matches.length > 0 && _.lTile.inMatch)) {
              nTile.select();
              if (_.numMatched >= 3) {
                _results.push(doMatch(nTile));
              } else {
                _results.push(void 0);
              }
            } else {
              _results.push(void 0);
            }
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(deselectBefore(_.hero));
        }
      }
      return _results;
    } else {
      nb = _.hero.t.neighbours();
      _results1 = [];
      for (dir in nb) {
        if (nb[dir] === nTile.t && _.path.length === 1) {
          _results1.push(nTile.select());
        } else {
          _results1.push(void 0);
        }
      }
      return _results1;
    }
  };

  deselectBefore = function(tile) {
    var l, o, p;
    p = _.path.length - 1;
    while (p >= 0) {
      if (tile.t === _.path[p].t || tile.t === _.hero.t) {
        o = _.path.length - 1;
        while (o > p) {
          _.path[o].deselect();
          _.path.splice(o, 1);
          l = _.path.length;
          if (l > 0) {
            _.lTile = _.path[l - 1];
          } else {
            _.lTile = null;
          }
          o--;
        }
      }
      p--;
    }
    return drawArrow();
  };

  spawnPlayer = function() {
    var tX, tY;
    tX = _.rnd.integerInRange(0, _.rSize);
    tY = _.rnd.integerInRange(0, _.cSize);
    _.hero.t = _.tileArray.getPiece({
      x: tX,
      y: tY
    });
    _.hero.x = _.hero.t.o.x;
    _.hero.y = _.hero.t.o.y;
    resetPath();
    _.uiFade.alpha = 1;
    return setPlayerCoords();
  };

  newRoom = function() {
    var col, row, _i, _j, _ref, _ref1;
    _.level++;
    _.tiles.callAll("reset");
    for (row = _i = 0, _ref = _.rSize; 0 <= _ref ? _i < _ref : _i > _ref; row = 0 <= _ref ? ++_i : --_i) {
      for (col = _j = 0, _ref1 = _.cSize; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; col = 0 <= _ref1 ? ++_j : --_j) {
        spawnTile(_.tileArray.getPiece({
          x: row,
          y: col
        }));
      }
    }
    spawnPlayer();
    checkMatches();
    setRoomSize();
    fadeIn();
    return doNextAction();
  };

  setRoomSize = function() {
    _.rSize = 5;
    _.cSize = _.rSize;
    _.tSize = Math.floor(_.width / _.rSize);
    _.startX = _.tSize / 2 + (_.width - _.tSize * _.rSize) / 2;
    return _.startY = _.tSize / 2 + (_.height - _.tSize * _.cSize) / 2;
  };

  spawnTile = function(tile) {
    tile.selected = false;
    tile.o.type = _.rnd.integerInRange(1, _.numTypes);
    tile.o.frame = tile.o.type - 1;
    tile.o.alpha = 1;
    setSize(tile.o, 1);
    return tile.o.isMatched = false;
  };

  checkMatches = function() {
    var match, matches, tile, _i, _j, _k, _len, _len1, _len2, _ref, _results;
    matches = _.tileArray.getMatches();
    _.tiles.setAll("isMatched", false);
    for (_i = 0, _len = matches.length; _i < _len; _i++) {
      match = matches[_i];
      for (_j = 0, _len1 = match.length; _j < _len1; _j++) {
        tile = match[_j];
        tile.o.isMatched = true;
      }
    }
    _.tiles.setAll("inMatch", false);
    _ref = _.matches;
    _results = [];
    for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
      match = _ref[_k];
      if (match.length < 3) {
        match = [];
        _.matches.pop();
      }
      _results.push((function() {
        var _l, _len3, _results1;
        _results1 = [];
        for (_l = 0, _len3 = match.length; _l < _len3; _l++) {
          tile = match[_l];
          _results1.push(tile.inMatch = true);
        }
        return _results1;
      })());
    }
    return _results;
  };

  doMatch = function(tile) {
    var match, matchType, _i, _len, _ref;
    if (_.matches[0] && tile.type === _.matches[_.matches.length - 1][0].type) {
      _.matches[_.matches.length - 1].push(tile);
      return tile.inMatch = true;
    } else {
      match = [];
      matchType = _.lTile.type;
      _ref = _.path;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        tile = _ref[_i];
        if (tile.type === matchType && !tile.inMatch) {
          match.push(tile);
          tile.inMatch = true;
        }
      }
      if (match.length >= 3) {
        _.matches.push(match);
      }
      return checkMatches();
    }
  };

  debugTiles = function() {
    if (_.uiFade.alpha === 0.4 || _.uiFade.alpha === 0) {
      return _.tiles.forEach(function(tile) {
        var color, tS, tX, tY;
        tX = (_.startX + tile.t.x * _.tSize) - _.tSize / 2.2;
        tY = (_.startY + tile.t.y * _.tSize) - _.tSize / 3;
        tS = (canvasSize / 20) / 3;
        color = "#fff";
        if (tile.type === -1) {
          color = "#ff0000";
        }
        if (tile.type === 0) {
          color = "#00ff00";
        }
        if (tile.isMatched && !tile.inMatch) {
          color = "#ff00ff";
        }
        if (tile.inMatch) {
          color = "#0000ff";
        }
        _.debug.renderText(tile.t.x + "," + tile.t.y, tX, tY - tS, color, tS + "px Courier");
        return _.debug.renderText(tile.type, tX, tY, color, tS + "px Courier");
      });
    }
  };

  drawArrow = function() {
    var tile, _i, _len, _ref;
    resetArrow();
    _ref = _.path;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      tile = _ref[_i];
      lineToTile(_.lTile);
      return;
    }
  };

  lineToTile = function(tile) {
    var arrow;
    console.log(tile);
    arrow = _.add.graphics(9, 0);
    _.fgGroup.add(arrow);
    arrow.lineStyle(2, checkArrowColour(tile));
    if (typeof lastTile === "undefined" || lastTile === null) {
      arrow.moveTo(_.hero.x, _.hero.y);
    } else {
      arrow.moveTo(lastTile.x, lastTile.y);
    }
    arrow.lineTo(tile.x, tile.y);
    return _.arrows.push(arrow);
  };

  increaseCombo = function() {
    _.combo++;
    if ((_.comboTimer != null) && _.comboTimer.timer.length > 0) {
      _.time.events.remove(_.comboTimer);
    }
    return _.comboTimer = _.time.events.add(_.comboTime, resetCombo);
  };

  startPath = function() {
    _.lTile = null;
    return _.uiFade.alpha = 0.4;
  };

  walkPath = function() {
    if ((_.lTile != null) && checkPath() && _.path.length > 1) {
      _.time.events.add(1000, setPlayerCoords);
      while (_.path.length > 0) {
        _.tilesToPop.push(_.path.shift().t);
      }
    }
    resetPath();
    return resetCombo();
  };

  resetArrow = function() {
    var arrow, _i, _len, _ref, _results;
    _ref = _.arrows;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      arrow = _ref[_i];
      _results.push(arrow.destroy());
    }
    return _results;
  };

  resetCombo = function() {
    return _.combo = 1;
  };

  checkForFalling = function() {
    return _.fallTiles = _.tileArray.applyGravity();
  };

  increaseScore = function() {
    var basePoints;
    basePoints = 10;
    return _.score += basePoints * _.combo;
  };

  setSize = function(o, s) {
    o.anchor.setTo(0.5, 0.5);
    o.width = s;
    return o.height = s;
  };

  match = function(_a, _b) {
    return _a.type === _b.type || _b.type === 0 || _b.type === -1;
  };

  initLine = function(line, width, color, x, y) {
    line.lineStyle(width, color);
    if ((x != null) && (y != null)) {
      return line.moveTo(x, y);
    }
  };

  checkPath = function() {
    return _.path.length > 3 || _.lTile.type === -1 && _.numMatched > 2 || _.numMatched === 0;
  };

  resetPath = function() {
    _.tiles.callAll("deselect");
    _.uiFade.alpha = 0;
    resetArrow();
    _.path = [_.hero];
    _.numMatched = 0;
    return _.matches = [];
  };

  checkArrowColour = function(tile) {
    switch (tile.type) {
      case -1:
        return "0xFFFFFF";
      case 1:
        return "0xFF0000";
      case 2:
        return "0x00FF00";
      case 3:
        return "0x0000FF";
      case 4:
        return "0xFFFF00";
      case 5:
        return "0xF0F000";
      default:
        return "0xFF00FF";
    }
  };

  createGame = function() {
    setRoomSize();
    initBG();
    initGrid();
    initUI();
    return newRoom();
  };

  initBG = function() {
    var col, row, xPos, yPos, _i, _j, _ref, _ref1, _results;
    _.bgGroup = _.add.group();
    _.tileGrid = _.add.graphics(0, 0);
    _.bgGroup.add(_.tileGrid);
    _.stage.backgroundColor = "#343435";
    initLine(_.tileGrid, 1, 0x000000, 0, 0);
    xPos = _.startX - _.tSize / 2;
    yPos = _.startY - _.tSize / 2;
    for (row = _i = 0, _ref = _.rSize + 1; 0 <= _ref ? _i <= _ref : _i >= _ref; row = 0 <= _ref ? ++_i : --_i) {
      _.tileGrid.moveTo(xPos, yPos + row * _.tSize);
      _.tileGrid.lineTo(xPos + _.rSize * _.tSize, yPos + row * _.tSize);
    }
    _results = [];
    for (col = _j = 0, _ref1 = _.cSize; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; col = 0 <= _ref1 ? ++_j : --_j) {
      _.tileGrid.moveTo(xPos + col * _.tSize, yPos);
      _results.push(_.tileGrid.lineTo(xPos + col * _.tSize, yPos + _.cSize * _.tSize));
    }
    return _results;
  };

  initGrid = function() {
    var col, row, _i, _ref, _results;
    _.gridMoving = false;
    _.lTile = null;
    _.tiles = _.add.group();
    _.tileArray = new jMatch3.Grid({
      width: _.rSize,
      height: _.cSize
    });
    _results = [];
    for (row = _i = 0, _ref = _.rSize; 0 <= _ref ? _i < _ref : _i > _ref; row = 0 <= _ref ? ++_i : --_i) {
      _results.push((function() {
        var _j, _ref1, _results1;
        _results1 = [];
        for (col = _j = 0, _ref1 = _.cSize; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; col = 0 <= _ref1 ? ++_j : --_j) {
          _results1.push(initTile(_.tileArray.getPiece({
            x: row,
            y: col
          })));
        }
        return _results1;
      })());
    }
    return _results;
  };

  initTile = function(_t) {
    var xPos, yPos;
    xPos = _.startX + _.tSize * _t.x;
    yPos = _.startY + _.tSize * _t.y;
    _t.o = _.add.sprite(xPos, yPos, "tile");
    _t.o.t = _t;
    setSize(_t.o, _.tSize - 20);
    _t.o.angle = Math.random() * (3 - (-3));
    pulseTile(_t.o);
    _.tiles.add(_t.o);
    _t.o.inputEnabled = true;
    _t.o.events.onInputOver.add(checkCollisions, this);
    _t.o.destroy = function() {
      increaseScore();
      destroyTween(_t.o);
      if (_.combo < 15) {
        _.combo++;
      }
      return this.isMatched = false;
    };
    _t.o.select = function() {
      if (!this.selected) {
        if (this.type !== -1) {
          _.numMatched++;
          this.alpha = 0.5;
        }
        _.path.push(this);
        _.lTile = this;
        this.selected = true;
        return drawArrow();
      }
    };
    _t.o.deselect = function() {
      if (this.selected) {
        if (this.type !== -1) {
          _.numMatched--;
          this.alpha = 1;
        }
        this.selected = false;
        if (_.matches.length > 0) {
          if (this.inMatch) {
            return _.matches[_.matches.length - 1].pop();
          }
        }
      }
    };
    _t.o.reset = function() {
      this.alpha = 0;
      return this.type = -1;
    };
    return _t.o.updateType = function() {
      if (this.alpha < 1) {
        return this.type = -1;
      }
    };
  };

  initUI = function() {
    _.fgGroup = _.add.group();
    _.input.onDown.add(startPath, this);
    _.input.onUp.add(walkPath, this);
    _.hero = _.add.sprite(-20, -20, "player");
    setSize(_.hero, _.tSize / 2);
    _.fgGroup.add(_.hero);
    _.uiFade = _.add.graphics(0, 0);
    _.uiFade.beginFill(0x000000);
    _.uiFade.alpha = 1;
    _.uiFade.drawRect(0, 0, _.width, _.height);
    return _.fgGroup.add(_.uiFade);
  };

  width = window.window.innerWidth - 15;

  height = window.window.innerHeight - 15;

  canvasSize = width >= height ? height : width;

  preload = function() {
    var n, _i;
    _.load.spritesheet("tile", "img/tiles.png", 300, 300);
    _.load.spritesheet("player", "img/hero.png", 16, 16);
    for (n = _i = 1; _i <= 15; n = ++_i) {
      _.load.audio("pop" + n, "snd/pop" + n + ".mp3");
    }
    return _.load.audio("new", "snd/next_level.mp3");
  };

  create = function() {
    initVars();
    return createGame();
  };

  update = function() {};

  render = function() {
    return debugTiles();
  };

  initVars = function() {
    _.tilesToPop = [];
    _.path = [];
    _.arrows = [];
    _.matches = [];
    _.score = 0;
    _.numMatched = 0;
    _.combo = 0;
    _.level = 0;
    _.numTypes = 4;
    return _.popTime = 10;
  };

  _ = new Phaser.Game(canvasSize, canvasSize, Phaser.CANVAS, "", {
    preload: preload,
    create: create,
    update: update,
    render: render
  });

}).call(this);
